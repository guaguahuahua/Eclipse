package com.xjtu.algorithm;

import java.util.LinkedList;

import com.xjtu.tree.Node;

public class HasSubtree {
	
	/**
	 * 向下寻找到第一个值相同的节点就退出，有问题，如果前面的不匹配，而后面存在匹配的结构，无法找到
	 * @param root1
	 * @param root2
	 * @return
	 */
    public boolean HasSubtree_1(Node root1, Node root2) {
        if(root1==null || root2==null){
            return false;
        }
        Node temp=backtrack(root1, root2);
        if(temp==null) {
        	return false;
        }else {
        	return compare(temp, root2);
        }
    }
	
    Node res = null;
    /**
     * 获得一个与root2值相同的节点
     * @param root1
     * @param root2
     * @return
     */
    public Node backtrack(Node root1, Node root2) {
    	
    	if(root1!=null) {
        	if(root1.left!=null) {
        		backtrack(root1.left, root2);
        	}
        	if(root1.data==root2.data) {
        		res=root1;
        		return res;
        	}
        	if(root1.right!=null) {
        		backtrack(root1.right, root2);
        	}
    	}
    	return res;
    }
    
    boolean flag=true;
    public boolean compare(Node r1, Node r2) {
//    	System.out.println(flag);
    	if(r1!=null && r2!=null) {
    		
    		if(r1.left!=null && r2.left!=null) {
    			compare(r1.left, r2.left);
    		}
    		if(r1.data!=r2.data) {
    			flag=false;
    			return flag; 
    		}
    		if(r1.right!=null && r2.right!=null) {
    			compare(r1.right, r2.right);
    		}
    	}
    	return flag;
    }
    
    public boolean HasSubtree(Node root1, Node root2) {
        if(root1==null || root2==null){
            return false;
        }
        //层序的方式
        LinkedList<Node> queue=new LinkedList<Node>();
        queue.add(root1);
        LinkedList<Node> sub=new LinkedList<Node>();
        while(!queue.isEmpty()) {
        	Node temp=queue.poll();
        	if(temp.data==root2.data) {
        		boolean judge=compare(temp, root2);
        		if(judge==true) {
        			return judge;
        		}else {
        			flag=true;
        		}
        	}
    		if(temp.left!=null) {
    			queue.add(temp.left);	
    		}
    		if(temp.right!=null) {
    			queue.add(temp.right);	
    		}        		
        	
        }
        return false;
    }
    
    public static void main(String []args) {
    	Node root=new Node(8);
    	Node n2=new Node(8);
    	Node n3=new Node(9);
    	Node n4=new Node(2);
    	Node n5=new Node(5);
//    	Node n6=new Node(4);
//    	Node n7=new Node(7);
    	
    	root.left=n2;
    	root.right=n3;
    	n2.left=n4;
    	n2.right=n5;
//    	n5.left=n6;
//    	n5.right=n7;
    	
    	
    	Node r=new Node(8);
    	Node n21=new Node(9);
    	Node n22=new Node(2);
    	r.left=n21;
    	r.right=n22;
//    	Node r=null;
    	HasSubtree judge=new HasSubtree();
    	boolean res=judge.HasSubtree(root, r);
    	System.out.println(res);
    }
}
